Week 6 
//17.09.2025
//prompt 1 (โจทย์ในห้อง)
//เขียนฟังก์ชัน doSomething(x) ที่รับข้อความ x เป็นพารามิเตอร์ แล้วคืนค่าเป็นฟังก์ชันอีกตัวหนึ่ง ซึ่งเมื่อถูกเรียก จะส่งข้อความ "hi, <x>" ออกมา
สัปดาห์นี้ได้เรียนเรื่องการเขียน functional programming เป็นเหมือนฟังก์ชั่นซ้อนฟังก์ชั่นแล้วประกาศตัวแปรใหม่เพื่อใช้งานฟังก์ชั้นนั้นเหมือนเหมือนทำแบบงานแบบเป็นชั้นประกาศตัวแปรมาแล้วใช้ฟังก์ชั่นนั้น ข้อแรกก็จะเป็นโจทย์ในห้อง ให้เขียน functional programming รับข้อความแล้ว return อีก function นึงโดยเป็นตัวที่เราเขียนเอง เริ่มประกาศฟังก์ชั่น  doSomething(x) รับค่า x แล้วประกาศอีก function นึงเพื่อเรียกใช้งาน  ให้ return `hi,${x}` แล้วตรง x ก็เป็นตัวที่เรากำหนดเองก็จะได้ hi ตามด้วยค่า x ที่เราพิมพ์ 
ข้อนี้ก็ได้ฝึกการเขียน functional programming ได้รู้ว่ามันเขียนยังไงแลัมีวิธการทำงานที่ต่างจากตัวอื่นอย่างไร เช่น Imperative ก็จะเป็รการทำอะไรทีละขั้นตอน ส่วน functional จะเน้นฟังก์ชัน, ไม่มี side-effect, immutable, declarative

//19.09.2025
//prompt 1
//เขียนฟังก์ชัน addPrefix(prefix) ที่รับข้อความ prefix แล้ว return ฟังก์ชันใหม่ที่เมื่อเรียก จะนำ prefix มาต่อกับข้อความที่ส่งเข้าไป
โจทย์นี้เป็นการฝึกเขียน closure อีกครั้ง โดยเราประกาศฟังก์ชัน addPrefix(prefix) ที่เก็บ prefix เอาไว้ แล้ว return ฟังก์ชันอีกตัว (addPrefix2) ที่จะรับข้อความใหม่เข้ามาแล้วต่อกับ prefix ที่เรากำหนดไว้ตั้งแต่แรก เช่น addPrefix("ID:") จะได้ฟังก์ชันใหม่ที่ต่อ "ID:" นำหน้า string ทุกครั้ง 
ข้อนี้ได้ฝึกการเขียน functional programming มากขึ้นทำให้เขียนได้คล่องขึ้น และได้ลองใส่ค่าตัวแปรมากกว่า 1 และนำมาบวกกันเป็น string ก็จะได้ข้อความที่ต่อกัน

//20.09.2025
//prompt 1 (โจทย์ในห้อง)
//เขียนฟังก์ชัน idGenerator() ที่เมื่อถูกเรียก จะคืนค่าเป็นฟังก์ชันอีกตัวหนึ่ง และฟังก์ชันที่ถูกคืนค่านี้จะทำหน้าที่สร้าง “รหัสตัวเลข” (id) ที่เพิ่มขึ้นทีละ 1 ทุกครั้งที่ถูกเรียกใช้งาน
ข้อนี้เป็นโจทย์ในห้องเช่นกัน ลักษณะคล้าย counter โดยใช้ closure เก็บค่าตัวแปร id ไว้ แล้วทุกครั้งที่เรียกฟังก์ชัน จะบวกค่าเพิ่มขึ้นเรื่อย ๆ เช่น เริ่มจาก 1, 2, 3 ไปเรื่อย ๆ 
ข้อนี้ได้ฝึกการใช้ closure เพื่อเก็บค่า state ของตัวแปรให้ไม่หายไปหลังจบการทำงานของฟังก์ชันหลักและได้ทวนความรู้เก่าๆในการเพิ่มเลขทีละหนึ่ง

//prompt 2
//เขียนฟังก์ชัน counter(start) ที่เริ่มนับจากเลข start แล้วทุกครั้งที่เรียก จะเพิ่มขึ้นทีละ 1
โจทย์นี้ต่อยอดจาก idGenerator โดยให้เราสามารถกำหนดจุดเริ่มต้นของ counter ได้เอง เช่น counter(19) ก็จะเริ่มจาก 19 แล้วเรียกครั้งถัดไปจะได้ 20, 21, 22 ไปเรื่อย ๆ
 ข้อนี้ได้ฝึกการประยุกต์ closure ให้ยืดหยุ่นขึ้น ได้ลองปรับการเริ่มนับได้ตามพารามิเตอร์ที่รับเข้ามา ได้ลองเขียน functional มากขึ้นและคล่องมากขึ้น

//22.09.2025
//prompt 1
//เขียนฟังก์ชัน sum รับตัวเลขมาแล้วคูณ 10
ข้อนี้เป็นโจทย์ให้เขียนฟังก์ชัน sum() ที่ return ฟังก์ชัน sum2(x) เอาไว้คูณค่าพารามิเตอร์ x ด้วย 10 ทุกครั้ง เช่น sumtotal(2) จะได้ 20, sumtotal(8) จะได้ 80 
โจทย์นี้ได้ฝึกการใช้ closure ร่วมกับค่าคงที่ ได้ลองใช้การคูณ

//prompt 2
//เขียนฟังก์ชัน makeMultiplier(factor) ที่รับตัวเลข factor เข้ามา แล้ว return ฟังก์ชันใหม่ ที่เวลาถูกเรียก จะนำเลขที่ส่งเข้ามาไปคูณกับ factor
ข้อนี้เป็นเวอร์ชันยืดหยุ่นขึ้นจาก sum โดยไม่ fix ค่าไว้ที่ 10 แต่ให้ส่งค่า factor เข้ามา เช่น makeMultiplier(5) ก็จะ return ฟังก์ชันที่เอาเลขที่ส่งมาไปคูณด้วย 5 ทุกครั้ง เช่น times5(2) = 10, times5(20) = 100 
ข้อนี้ช่วยให้เห็นว่าการใช้ closure สามารถสร้างฟังก์ชันเฉพาะทางที่จำค่าตัวแปร factor ไว้ใช้งานต่อไปได้